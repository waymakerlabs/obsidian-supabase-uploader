import { UploadImageUseCase } from '../../../src/application/usecases/UploadImageUseCase';
import { ImageFile, ImageValidationError } from '../../../src/domain/entities/ImageFile';
import { MockStorageService } from '../../mocks/MockStorageService';
import { MockPathGenerator } from '../../mocks/MockPathGenerator';

describe('UploadImageUseCase', () => {
  let useCase: UploadImageUseCase;
  let mockStorage: MockStorageService;
  let mockPathGenerator: MockPathGenerator;

  beforeEach(() => {
    mockStorage = new MockStorageService();
    mockPathGenerator = new MockPathGenerator();
    useCase = new UploadImageUseCase(mockStorage, mockPathGenerator);
  });

  afterEach(() => {
    mockStorage.reset();
    mockPathGenerator.reset();
  });

  describe('execute', () => {
    it('should successfully upload a valid image', async () => {
      const buffer = Buffer.from('fake-image-data');
      const imageFile = ImageFile.create({
        name: 'test.png',
        mimeType: 'image/png',
        data: buffer,
        size: buffer.length,
      });

      const result = await useCase.execute(imageFile);

      expect(result.isSuccess).toBe(true);
      expect(result.url).toContain('https://mock-storage.example.com');
      expect(mockPathGenerator.getCallCount()).toBe(1);
      expect(mockStorage.uploadedFiles.length).toBe(1);
    });

    it('should generate correct markdown link', async () => {
      const buffer = Buffer.from('fake-image-data');
      const imageFile = ImageFile.create({
        name: 'photo.jpg',
        mimeType: 'image/jpeg',
        data: buffer,
        size: buffer.length,
      });

      const result = await useCase.execute(imageFile);

      expect(result.toMarkdown()).toMatch(/^!\[\]\(https:\/\/.*\)$/);
    });

    it('should handle storage failure gracefully', async () => {
      mockStorage.setFailure(true, 'Network error');

      const buffer = Buffer.from('fake-image-data');
      const imageFile = ImageFile.create({
        name: 'test.png',
        mimeType: 'image/png',
        data: buffer,
        size: buffer.length,
      });

      const result = await useCase.execute(imageFile);

      expect(result.isSuccess).toBe(false);
      expect(result.error).toBe('Network error');
    });

    it('should use the path generated by pathGenerator', async () => {
      mockPathGenerator.setPath('custom/path/image.png');

      const buffer = Buffer.from('fake-image-data');
      const imageFile = ImageFile.create({
        name: 'test.png',
        mimeType: 'image/png',
        data: buffer,
        size: buffer.length,
      });

      await useCase.execute(imageFile);

      expect(mockStorage.uploadedFiles[0].path).toBe('custom/path/image.png');
    });
  });

  describe('executeFromRaw', () => {
    it('should create ImageFile and upload', async () => {
      const buffer = Buffer.from('fake-image-data');

      const result = await useCase.executeFromRaw({
        name: 'test.png',
        mimeType: 'image/png',
        data: buffer,
        size: buffer.length,
      });

      expect(result.isSuccess).toBe(true);
      expect(mockStorage.uploadedFiles.length).toBe(1);
    });

    it('should return failure for invalid MIME type', async () => {
      const buffer = Buffer.from('fake-data');

      const result = await useCase.executeFromRaw({
        name: 'document.pdf',
        mimeType: 'application/pdf',
        data: buffer,
        size: buffer.length,
      });

      expect(result.isSuccess).toBe(false);
      expect(result.error).toContain('Unsupported MIME type');
    });

    it('should return failure for oversized file', async () => {
      const largeBuffer = Buffer.alloc(11 * 1024 * 1024); // 11MB

      const result = await useCase.executeFromRaw({
        name: 'huge.png',
        mimeType: 'image/png',
        data: largeBuffer,
        size: largeBuffer.length,
      });

      expect(result.isSuccess).toBe(false);
      expect(result.error).toContain('exceeds maximum');
    });
  });
});
